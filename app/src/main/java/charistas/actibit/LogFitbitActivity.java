package charistas.actibit;

import android.app.DatePickerDialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.app.FragmentTransaction;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.text.InputType;
import android.view.View;
import android.widget.Button;
import android.widget.DatePicker;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.TimePicker;
import android.widget.Toast;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import charistas.actibit.api.EndpointInterface;
import charistas.actibit.api.QuickPreferences;
import retrofit.Callback;
import retrofit.GsonConverterFactory;
import retrofit.Retrofit;

import static charistas.actibit.api.QuickPreferences.CODE_BAD_GATEWAY;
import static charistas.actibit.api.QuickPreferences.CODE_CREATED;
import static charistas.actibit.api.QuickPreferences.CODE_INTERNAL_SERVER_ERROR;
import static charistas.actibit.api.QuickPreferences.CODE_OK;
import static charistas.actibit.api.QuickPreferences.CODE_UNAUTHORIZED;
import static charistas.actibit.api.QuickPreferences.DATE;
import static charistas.actibit.api.QuickPreferences.DISTANCE;
import static charistas.actibit.api.QuickPreferences.DURATION;
import static charistas.actibit.api.QuickPreferences.START_TIME;

/**
 * This class is responsible for handling the input process for the parameters of a chosen activity
 * and for communicating with Fitbit's servers while sending these parameters.
 */
public class LogFitbitActivity extends AppCompatActivity implements View.OnClickListener, SetDurationDialogFragment.OnDurationInputDoneListener, SetDistanceDialogFragment.OnDistanceInputDoneListener {
    TextView [] labels = null;
    EditText[] inputs = null;

    DatePickerDialog datePicker;
    TimePickerDialog timePickerDialog;

    static SimpleDateFormat dateFormatter;
    static SimpleDateFormat timeFormatter;

    EditText dateEditText;
    EditText timeEditText;
    EditText durationEditText;
    EditText distanceEditText;

    Context context;

    EndpointInterface apiService;

    static Map<String, String> allLabels = new HashMap<>();

    static {
        allLabels.put(DATE, "Date");
        allLabels.put(START_TIME, "Start time");
        allLabels.put(DURATION, "Duration");
        allLabels.put(DISTANCE, "Distance");

        dateFormatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        timeFormatter = new SimpleDateFormat("kk:mm", Locale.US);
    }

    /**
     * Configures the UI of the activity, by creating the labels and the input fields of the
     * required parameters.
     * @param savedInstanceState The state generated by a previous instance of this activity
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_log);

        context = this;

        Bundle extras = getIntent().getExtras();
        String activityName = extras.getString("FitbitActivityName");

        // Get the required parameters names
        String [] currentActivityParameters = FitbitActivity.getAllParameters().get(activityName);
        int totalParameters = currentActivityParameters.length;
        labels = new TextView[totalParameters];
        inputs = new EditText[totalParameters];

        LinearLayout layout = (LinearLayout) findViewById(R.id.myLinearLayout);

        for (int i = 0; i < labels.length; i++) {
            TextView label = new TextView(this);
            final EditText input = new EditText(this);

            // Configure the labels and input fields for each of the needed parameters
            label.setText(allLabels.get(currentActivityParameters[i]));
            Calendar calendar = Calendar.getInstance();
            switch(currentActivityParameters[i]) {
                case DATE:
                    input.setOnClickListener(this);
                    datePicker = new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() {
                        @Override
                        public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {
                            Calendar newDate = Calendar.getInstance();
                            newDate.set(year, monthOfYear, dayOfMonth);
                            input.setText(dateFormatter.format(newDate.getTime()));
                        }
                    },calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
                    input.setInputType(InputType.TYPE_NULL);
                    dateEditText = input;
                    break;
                case START_TIME:
                    input.setOnClickListener(this);
                    timePickerDialog = new TimePickerDialog(this, new TimePickerDialog.OnTimeSetListener() {
                        @Override
                        public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
                            Calendar time = Calendar.getInstance();
                            time.set(Calendar.HOUR_OF_DAY, hourOfDay);
                            time.set(Calendar.MINUTE, minute);
                            input.setText(timeFormatter.format(time.getTime()));
                        }
                    },calendar.get(Calendar.HOUR), calendar.get(Calendar.MINUTE), true);
                    input.setInputType(InputType.TYPE_NULL);
                    timeEditText = input;
                    break;
                case DURATION:
                    input.setOnClickListener(this);
                    input.setInputType(InputType.TYPE_NULL);
                    durationEditText = input;
                    break;
                case DISTANCE:
                    input.setOnClickListener(this);
                    input.setInputType(InputType.TYPE_NULL);
                    distanceEditText = input;
                    break;
            }
            layout.addView(label);
            layout.addView(input);

            labels[i] = label;
            inputs[i] = input;
        }

        final String chosenActivity = activityName;

        // Configures the function of the OK button. If the user hasn't given all the required input
        // data, then he is told to do so.
        Button button = new Button(this);
        button.setText(getString(R.string.OK));
        button.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v) {
                for (EditText input : inputs) {
                    if (input.getText().toString().equals("")) {
                        Toast.makeText(context, getString(R.string.missing_parameters), Toast.LENGTH_SHORT).show();
                        return;
                    }
                }
                postData(chosenActivity);
            }
        });
        layout.addView(button);
    }

    /**
     * Responsible for reading the input fields for date, start time, duration and distance and
     * communicating with Fitbit's servers in order to send the aforementioned data.
     * @param activityName Name of the chosen activity
     */
    @SuppressWarnings("unchecked")
    public void postData(final String activityName) {
        SharedPreferences prefs = getSharedPreferences("charistas.actibit", MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        editor.putInt(activityName +"_timesUsed", prefs.getInt(activityName +"_timesUsed", 0) + 1).apply();

        // Get the authorization token
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        String fullAuthToken = sharedPrefs.getString(QuickPreferences.FULL_AUTHORIZATION, null);

        // Get the chosen activity's parameters
        final Map<String, String> ids = FitbitActivity.getActivities(prefs);
        final Map<String, String[]> allParameters = FitbitActivity.getAllParameters();
        String activityId = ids.get(activityName);
        String [] currentParameters = allParameters.get(activityName);
        String date = null, startTime = null, duration = null, distance = null;

        initialiseRetrofit();

        // Based on which activity is chosen, read the appropriate data and connect to Fitbit's
        // servers by using the Retrofit library.
        switch (activityName) {
            case "Tennis":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logTennis(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Cycling":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DISTANCE:
                            distance = inputs[i].getText().toString().split(" ")[0];
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logCycling(fullAuthToken, activityId, date, startTime, duration, distance).enqueue(callback);
                break;
            case "Cleaning":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logCleaning(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Cooking":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logCooking(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Basketball":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logBasketball(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Billiard":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logBilliard(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Soccer":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logSoccer(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Yoga":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logYoga(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Volleyball":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logVolleyball(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
            case "Swimming":
                for (int i = 0; i < currentParameters.length; i++) {
                    switch (currentParameters[i]) {
                        case QuickPreferences.DATE:
                            date = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.START_TIME:
                            startTime = inputs[i].getText().toString();
                            break;
                        case QuickPreferences.DURATION:
                            duration = convertDurationToMilliseconds(inputs[i].getText().toString());
                            break;
                    }
                }
                apiService.logSwimming(fullAuthToken, activityId, date, startTime, duration).enqueue(callback);
                break;
        }
        finish();
    }

    /**
     * Converts the duration string into milliseconds.
     * @param duration Duration in the form of '2 hours and 30 minutes'
     * @return The duration in milliseconds
     */
    public String convertDurationToMilliseconds(String duration) {
        String [] result = duration.split(" ");
        int hours = Integer.parseInt(result[0]);
        int minutes = Integer.parseInt(result[3]);
        int milliseconds = ((hours * 60) + minutes) * 60000;
        return Integer.toString(milliseconds);
    }

    /**
     * Initialize the Retrofit library.
     */
    public void initialiseRetrofit() {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(QuickPreferences.BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        apiService = retrofit.create(EndpointInterface.class);
    }

    /**
     * Displays the appropriate dialog based on what the user clicked on.
     * @param view The chosen View
     */
    @Override
    public void onClick(View view) {
        if (view == dateEditText) {
            datePicker.show();
        }
        else if (view == timeEditText) {
            timePickerDialog.show();
        }
        else if (view == durationEditText) {
            showDurationDialogFragment();
        }
        else if (view == distanceEditText) {
            showDistanceDialogFragment();
        }
    }

    /**
     * Displays the dialog that prompts the user to enter the duration.
     */
    void showDurationDialogFragment() {
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        Fragment previous = getFragmentManager().findFragmentByTag("dialog");
        if (previous != null) {
            fragmentTransaction.remove(previous);
        }
        fragmentTransaction.addToBackStack(null);

        DialogFragment dialog = SetDurationDialogFragment.createFragment();
        dialog.show(fragmentTransaction, "dialog");
    }

    /**
     * Displays the dialog that prompts the user to enter the distance.
     */
    void showDistanceDialogFragment() {
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        Fragment previous = getFragmentManager().findFragmentByTag("dialog");
        if (previous != null) {
            fragmentTransaction.remove(previous);
        }
        fragmentTransaction.addToBackStack(null);
        DialogFragment dialog = SetDistanceDialogFragment.createFragment();
        dialog.show(fragmentTransaction, "dialog");
    }

    /**
     * Called when the user clicks OK on the SetDurationDialogFragment dialog. Sets the appropriate
     * message on the duration field according to the chosen parameters.
     * @param hours The 'hours' part of the duration
     * @param minutes The 'minutes' part of the duration
     */
    public void onDone(String hours, String minutes) {
        if (hours.equals("1")) {
            durationEditText.setText(hours +getString(R.string.hour_duration_part) +minutes +getString(R.string.minutes_duration_part));
        }
        else {
            durationEditText.setText(hours +getString(R.string.hours_duration_part) +minutes +getString(R.string.minutes_duration_part));
        }
    }

    /**
     * Called when the user clicks OK on the SetDistanceDialogFragment dialog. Sets the appropriate
     * message to the distance field according to the chosen parameters.
     * @param distance The distance
     */
    public void onDone(String distance) {
        distanceEditText.setText(String.format(getString(R.string.distance), distance));
    }

    /**
     * Handles the reply that Fitbit's servers send to the app and displays the appropriate message.
     */
    Callback callback = new Callback<Void>() {
        @Override
        public void onResponse(retrofit.Response response, Retrofit retrofit) {
            if ( (response.code() == CODE_CREATED) || (response.code() == CODE_OK) ) {
                Toast.makeText(context, getString(R.string.sent), Toast.LENGTH_LONG).show();
            }
            else if (response.code() == CODE_UNAUTHORIZED) {
                Toast.makeText(context, getString(R.string.authentication_needed), Toast.LENGTH_LONG).show();
            }
            else if (response.code() == CODE_INTERNAL_SERVER_ERROR) {
                Toast.makeText(context, getString(R.string.something_wrong_at_fitbit), Toast.LENGTH_LONG).show();
            }
            else if (response.code()  == CODE_BAD_GATEWAY) {
                Toast.makeText(context, getString(R.string.maintenance), Toast.LENGTH_LONG).show();
            }
            else {
                Toast.makeText(context, getString(R.string.unknown_error_part_1) +response.message() +getString(R.string.unknown_error_part_2) +response.code(), Toast.LENGTH_LONG).show();
            }
        }

        @Override
        public void onFailure(Throwable throwable) {
            throwable.printStackTrace();
        }
    };
}
